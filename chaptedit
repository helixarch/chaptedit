#!/usr/bin/bash


#	Copyright 2017 George Savvidis, Odysseas Raftopoulos

#	This program is free software: you can redistribute it and/or modify
#	it under the terms of the GNU General Public License as published by
#	the Free Software Foundation, either version 2 of the License, or
#	(at your option) any later version.

#	This program is distributed in the hope that it will be useful,
#	but WITHOUT ANY WARRANTY; without even the implied warranty of
#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#	GNU General Public License for more details.

#	You should have received a copy of the GNU General Public License
#	along with this program.  If not, see <http://www.gnu.org/licenses/>.


# Define colors and bold letters
red=$(tput setaf 1)
green=$(tput setaf 2)
cyan=$(tput setaf 6)
bold=$(tput bold)
normal=$(tput sgr0)

# Define carriage return and new line
cr=$(echo -e "\r")
nl=$(echo -e "\n")

# Define regular expressions
regextime="^CHAPTER([0-9][0-9])=([0-9][0-9]):([0-9][0-9]):([0-9][0-9])\.([0-9][0-9][0-9])$cr$"
regexname="^CHAPTER([0-9][0-9])NAME=(.*)$cr$"
regexemptyline="^($cr$nl|$nl|$cr)$"


# Help
get_help ()
{
case $((10#$(date +%S)%2)) in
	0) authors[0]="George Savvidis (stargr@gmail.com)"; authors[1]="Odysseas Raftopoulos" ;;
	1) authors[0]="Odysseas Raftopoulos"; authors[1]="George Savvidis (stargr@gmail.com)" ;;
esac

text1="
${cyan}NAME${normal}
  chaptedit


${cyan}DESCRIPTION${normal}
  Command line ogm (txt) type chapters editor.
  Can read xml type as well but the output is always txt.


${cyan}PARAMETERS${normal}
  ${bold}-i \"Input file\"${normal}
      Chapters file to process.
      Does not work with -D parameter (synchronize with directory) and -r parameter (recurse).

  ${bold}-d \"Input directory\"${normal}
      Directory containing chapters files to process. Works with all parameters except with -y (synchronize with
      file) and -j (join two txt chapters files). Instead of Synchronize with file you can use Synchronize with directory
      (-D parameter).

  ${bold}-r [Switch]${normal}
      Searches recursively for chapters files in directory given with -d parameter.

  ${bold}-b [Switch]${normal}
      Backup input file. Makes a copy of the input file in the same directory with the .bak suffix.
      If the backup already exists, it does nothing. If -b is not set and the backup file exists, it is removed.
      Can be used with any other parameter.

  ${bold}-s (+/-/a/z)hh:mm:ss,fff${normal}
      Shift time. Plus sign (or no sign at all) adds time, where the minus sign subtracts time.
      \"a\" and \"z\" indicate absolute time value for the beginning and end time of the chapters file respectively.

  ${bold}-p [Switch]${normal}
      Change the fps from NTSC (23.976/29.970) to PAL (25).

  ${bold}-n [Switch]${normal}
      Change the fps from PAL (25) to NTSC (23.976/29.970).

  ${bold}-a (+/-)hh:mm:ss,fff (+/-)hh:mm:ss,fff${normal}
      Adjust time. Beginning and end time will be set to these values and the rest will be adjusted proportionally.
      The time value is absolute if you don't use the +/- and will be shifted if you do use either sign.

  ${bold}-1 (+/-)hh:mm:ss,fff${normal}
      Adjust time. Beginning time will be set to this value and the rest will be adjusted proportionally.
      The time value is absolute if you don't use the +/- and will be shifted if you do use either sign.

  ${bold}-2 (+/-)hh:mm:ss,fff${normal}
      Adjust time. End time will be set to this value and the rest will be adjusted proportionally.
      The time value is absolute if you don't use the +/- and will be shifted if you do use either sign.

  ${bold}-y \"Input file\"${normal}
      Synchronize with file. The chapter times of the txt given with -i parameter will be adjusted with
      beginning and end time of this txt.

  ${bold}-D \"Input directory\"${normal}
      Synchronize with directory. To be used only with -d parameter.
      This directory contains txt chapters files with correct times.
      The two directories (given with -d and -D parameters) must contain txt chapters files with the same names.
      Synchronizes each txt chapters file in the input directory (-d) with the txt chapters file with the
      same name that's in the directory (-D).

  ${bold}-Y [Switch]${normal}
      Synchronize chapter times one by one. Optional switch to be used with -y and -D. Replaces times of file
      to be synchronized with times of synchronization file, respectively.

  ${bold}-f \"Find text\"${normal}
      Search, case insensitive. The double quotes are necessary.

  ${bold}-F \"Find text\"${normal}
      Search, case sensitive. The double quotes are necessary.

  ${bold}-e \"Text to be replaced\" \"New text\"${normal}
      Replace, case insensitive. The double quotes are necessary.

  ${bold}-E \"Text to be replaced\" \"New text\"${normal}
      Replace, case sensitive. The double quotes are necessary.

  ${bold}-j \"Input file\"${normal}
      Join two txt chapters files. This txt will be appended to the txt given with -i parameter.

  ${bold}-J hh:mm:ss,fff${normal}
      Join time. Optional parameter, to be used with -j. Shifts the time after beginning of the second txt
      in the output file.

  ${bold}-x (+/-)hh:mm:ss,fff${normal} or ${bold}(+/-)CHAPT_INTEGER${normal} or ${bold}(+/-)INTEGER:INTEGERt${normal} or ${bold}(+/-)INTEGER:INTEGERn${normal}
      Split txt chapters file. Can take 4 different syntaxes:
        i)   (+/-)hh:mm:ss,fff:     splitting time.
        ii)  (+/-)CHAPT_INTEGER:      splitting chapter integer.
        iii) (+/-)INTEGER:INTEGERt: fraction where we split the chapters file according to total time.
        iv)  (+/-)INTEGER:INTEGERn: fraction where we split the chapters file according to number of chapters.
      The minus sign means that counting begins from the end of the chapters file.
      The plus sign means that counting begins from the beginning. (Equivalent of using no sign at all).

  ${bold}-X [Switch]${normal}
      Split time. Optional switch, to be used with -x. Makes the second generated txt begin with time 00:00:00,000.
      Can be used with any -x syntax.

  ${bold}-h [Switch]${normal}
      Display help.

  ${bold}-H [Switch]${normal}
      Display help with more information and examples.\n\n\n"

examplecounter=1

text2="${cyan}NOTES${normal}
  • If the argument is a chapters file you can give a relative or absolute path or a filename in the working directory.
  • Filenames must be enclosed in quotes if they contain spaces or other special characters (including wildcards).
  • Do not use \"~\" or \"\$HOME\" to symbolize the home directory. Write the text instead (/home/yourname).
  • -i (input file) or -d (input directory) is required in every case.
  • If only -i parameter is used then the chapters file goes through a basic clean-up (empty chapters are removed etc.)
  • -1 and -2 parameters (adjust time) can be combined (equivalent of using just the -a parameter).
  • You can put different parameters in the same command and they'll run one after the other.
  • Bellow you'll find examples for every parameter.\n\n\n"


text2+="${cyan}EXAMPLES${normal}
  ${bold}Basic clean-up (purify)${normal}

  ${bold}${green}Example $((exmpl=examplecounter++))${normal}
  chaptedit -i foo.txt
  Removes empty chapters, duplicate chapters and extra empty lines.\n\n"


text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  chaptedit -i \"*.txt\"
  Same as above, but applies to all .txt files.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  chaptedit -i foo.txt -b
  Same as Example $exmpl, but creates a backup before processing the chapters file.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  chaptedit -d foo_directory
  Runs Basic clean-up for all chapters files in directory \"foo_directory\".\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  chaptedit -d foo_directory -r
  Same as above, but also processes chapters found in subdirectories (unlimited depth) as well.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  chaptedit -d \"Season*\" -b
  Runs Basic clean-up for all chapters found in all folders that begin with \"Season\" and
  creates a backup for each chapters file.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  chaptedit -d \"Season [1-3,5]\"
  Runs Basic clean-up for all chapters found in the folders \"Season 1\", \"Season 2\", \"Season 3\" and \"Season 5\".\n\n\n"


text2+="  ${bold}Shift time${normal}

  ${bold}${green}Example $((examplecounter++))${normal}
  chaptedit -i foo.txt -s 00:00:03,100
  Shifts time by 3.1 seconds.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  chaptedit -i foo.txt -s +00:00:03,100
  The same as above.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  chaptedit -i foo.txt -s -00:00:02,500
  Shifts time by -2.5 seconds.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  chaptedit -i foo.txt -s a00:00:11,530
  Calculates and applies the appropriate shift time value so that the first chapter is at 00:00:11,530.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  chaptedit -i foo.txt -s z01:38:32,600
  Calculates and applies the appropriate shift time value so that the last chapter is at 01:38:32,600.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  chaptedit -i \"*.txt\" -s 00:00:02,000
  Shifts time by 2.0 seconds in all .txt chapters files.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  chaptedit -d foo_directory -s 00:00:01,700
  Shifts time by 1.7 seconds in all .txt chapters files in directory \"foo_directory\".\n\n\n"


text2+="  ${bold}Convert NTSC to PAL${normal}

  ${bold}${green}Example $((examplecounter++))${normal}
  chaptedit -i foo.txt -p\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  chaptedit -i \"*.txt\" -p
  Converts the fps in all .txt chapters files.\n\n\n"


text2+="  ${bold}Convert PAL to NTSC${normal}

  ${bold}${green}Example $((examplecounter++))${normal}
  chaptedit -i foo.txt -n\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  chaptedit -d foo_directory -n
  Converts the fps in all .txt chapters files in directory \"foo_directory\" from PAL to NTSC.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  chaptedit -d foo_directory -r -n
  Same as above, but also processes chapters found in subdirectories (unlimited depth) as well.\n\n\n"


text2+="  ${bold}Adjust time${normal}

  ${bold}${green}Example $((examplecounter++))${normal}
  chaptedit -i foo.txt -a 00:00:17,360 00:48:02,200
  Sets beginning time to 00:00:17,360 and end time to 00:48:02,200.
  Both times are absolute.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  chaptedit -i foo.txt -a +00:00:02,600 -00:00:05,920
  Shifts beginning time by +00:00:02,600 and end time by -00:00:05,920.
  Both times are relative.\n\n"


text2+="  ${bold}${green}Example $((exmpl=examplecounter++))${normal}
  chaptedit -i foo.txt -a 00:00:17,360 -00:00:05,920
  Sets beginning time to 00:00:17,360 and shifts end time by -00:00:05,920.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  chaptedit -i foo.txt -1 00:00:17,360
  Sets beginning time to 00:00:17,360.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  chaptedit -i foo.txt -2 +00:00:03,810
  Shifts end time by 00:00:03,810.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  chaptedit -i foo.txt -1 00:00:17,360 -2 -00:00:05,920
  This has the same result as Example $exmpl.\n\n\n"


text2+="  ${bold}Synchronize with file${normal}

  ${bold}${green}Example $((examplecounter++))${normal}
  chaptedit -i foo.txt -y boo.txt
  Synchronizes foo.txt with boo.txt. Chapters times of foo.txt
  will be adjusted with beginning and end time of boo.txt.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  chaptedit -i foo.txt -y boo.txt -Y
  Synchronizes foo.txt with boo.txt. Subtitle times of foo.txt
  wil will be replaced with times of boo.txt respectively.\n\n\n"


text2+="  ${bold}Synchronize with directory${normal}

  ${bold}${green}Example $((examplecounter++))${normal}
  chaptedit -d foo_directory -D boo_directory
  Synchronizes each txt chapters file in the directory \"foo_directory\" with the txt chapters file
  that has the same name that's in the directory \"boo_directory\".\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  chaptedit -d foo_directory -D boo_directory -Y
  Synchronizes each chapters file's times in the directory \"foo_directory\" with the txt
  chapters file's times that has the same name that's in the directory \"boo_directory\",
  respectively.\n\n\n"


text2+="  ${bold}Find text${normal}

  ${bold}${green}Example $((examplecounter++))${normal}
  chaptedit -i foo.txt -f \"Whatever you want\"
  Searches text \"whatever you want\" (case insensitive) and prints the lines that contain it.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  chaptedit -i foo.txt -F \"Name, please.\"
  Searches text \"Name, please.\" (case sensitive) and prints the lines that contain it.\n\n\n"


text2+="  ${bold}Replace text${normal}

  ${bold}${green}Example $((examplecounter++))${normal}
  chaptedit -i foo.txt -e \"George Smlth\" \"George Smith\"
  Replaces text \"george smlth\" (case insensitive) with \"George Smith\".\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  chaptedit -i foo.txt -E \"i'm\" \"I'm\"
  Replaces text \"i'm\" (case sensitive) with \"I'm\".\n\n\n"

  
text2+="  ${bold}Join two txt${normal}

  ${bold}${green}Example $((examplecounter++))${normal}
  chaptedit -i foo.txt -j boo.txt
  Joins foo.txt and boo.txt to a new file foo_join.txt.
  The chapter times in boo.txt are added unmodified.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  chaptedit -i foo.txt -j boo.txt -J 00:48:05,956
  Joins foo.txt and boo.txt to a new file foo_join.txt.
  The chapter times in boo.txt are shifted by 00:48:05,956 before added.\n\n\n"


text2+="  ${bold}Split txt to two files${normal}

  ${bold}${green}Example $((examplecounter++))${normal}
  chaptedit -i foo.txt -x 01:02:39,000
  Splits foo.txt at 01:02:39,000 to two files foo_1.txt and foo_2.txt.
  The chapter times in foo_2.txt remain unmodified.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  chaptedit -i foo.txt -x -00:59:14,000
  Splits foo.txt at 00:59:14,000 (counting from the end) to two files foo_1.txt and foo_2.txt.
  The chapter times in foo_2.txt remain unmodified.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  chaptedit -i foo.txt -x 431
  Splits foo.txt at chapter number 431 to two files foo_1.txt and foo_2.txt.
  The chapter times in foo_2.txt remain unmodified.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  chaptedit -i foo.txt -x -399
  Splits foo.txt at chapter number 399 (counting from the end) to two files foo_1.txt and foo_2.txt.
  The chapter times in foo_2.txt remain unmodified.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  chaptedit -i foo.txt -x 1:2t
  Splits foo.txt at 1/2 of total time to two files foo_1.txt and foo_2.txt.
  The chapter times in foo_2.txt remain unmodified.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  chaptedit -i foo.txt -x -2:3t
  Splits foo.txt at 2/3 of total time (counting from the end) to two files foo_1.txt and foo_2.txt.
  The chapter times in foo_2.txt remain unmodified.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  chaptedit -i foo.txt -x 3:4n
  Splits foo.txt at 3/4 of total chapters to two files foo_1.txt and foo_2.txt.
  The chapter times in foo_2.txt remain unmodified.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  chaptedit -i foo.txt -x -1:5n
  Splits foo.txt at 1/5 of total chapters (counting from the end) to two files foo_1.txt and foo_2.txt.
  The chapter times in foo_2.txt remain unmodified.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  chaptedit -i foo.txt -x 01:02:39,000 -X
  Splits foo.txt at 01:02:39,000 to two files foo_1.txt and foo_2.txt.
  foo_2.txt begins with time 00:00:00,000.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  chaptedit -i foo.txt -x -399 -X
  Splits foo.txt at chapter number 399 (counting from the end) to two files foo_1.txt and foo_2.txt.
  foo_2.txt begins with time 00:00:00,000.\n\n\n"


text2+="${cyan}ABOUT${normal}
  Authors:      ${authors[0]}
                ${authors[1]}

  This program is licensed under GPLv2.\n\n"

printf "$text1"
if [[ $longhelp ]]; then
	printf "$text2"
fi
exit 0
}


# If no parameter is given then exit
if ( ! getopts ":i:d:rbs:pna:1:2:y:D:Yf:F:e:E:j:J:x:XhH" opt); then
	echo "Try 'chaptedit -h' for more information."; exit 1;
fi

# Processing parameters
while getopts ":i:d:rbs:pna:1:2:y:D:Yf:F:e:E:j:J:x:XhH" parameter; do
	case "$parameter" in
		i) inputfilename=$OPTARG ;;
		d) inputdirectory=$OPTARG ;;
		r) recurse="True" ;;
		b) backup="True" ;;
		s) shifttime=$OPTARG ;;
		p) ntsc2pal="True" ;;
		n) pal2ntsc="True" ;;
		a)	eval "adjustfirst=\$$((OPTIND-1))"
			eval "adjustlast=\$$((OPTIND))"
			((OPTIND++)) ;;
		1) adjustonlyfirst=$OPTARG ;;
		2) adjustonlylast=$OPTARG ;;
		y) synchronizefile=$OPTARG ;;
		D) synchronizedirectory=$OPTARG ;;
		Y) synchronizetimebytime="True" ;;
		f) findci=$OPTARG ;;
		F) findcs=$OPTARG ;;
		e)	eval "replace1=\$$((OPTIND-1))"
			eval "replace2=\$$((OPTIND))"
			((OPTIND++)) ;;
		E)	eval "replace3=\$$((OPTIND-1))"
			eval "replace4=\$$((OPTIND))"
			((OPTIND++)) ;;
		j) jointxt=$OPTARG ;;
		J) jointime=$OPTARG ;;
		x) splittxt=$OPTARG ;;
		X) splittime="True" ;;
		h) get_help ;;
		H) longhelp="True"; get_help ;;
		?) echo -e "${red}Error: Parameter -$OPTARG is unknown or an argument is missing.${normal}\nTry 'chaptedit -h' for more information."; exit 1 ;;
	esac
done

if ! [[ $inputfilename ]] && ! [[ $inputdirectory ]]; then
	echo -e "${red}Error: -i (input file) or -d (input directory) is required in every case${normal}\nTry 'chaptedit -h' for more information."
	exit 1
fi


### Helper functions
check_file ()
{
	if ! [[ -f "$1" ]]; then
		echo "${red}Error: \"$1\" not found.${normal}"
		return 1
	fi

	if ! [[ -r "$1" ]]; then
		echo "${red}Error: \"$1\" is not readable.${normal}"
		return 1
	fi

	encoding=$(file -b --mime-encoding "$1")
	if [[ $encoding == "binary" ]] || ! [[ $(file -b "$1") == *"text"* ]] && ! [[ $(file -b "$1") == *"Bio-Rad .PIC Image File"* ]]; then
		echo "${red}Error: \"$1\" is not a text file or it is UTF-16 without BOM${normal}"
		return 1
	fi

	# Check the file extension and create backup if it's not txt
	extension="${1##*.}"
	if [[ "${extension,,}" != "txt" ]] && [[ "${extension,,}" != "ogm" ]] && [[ "${extension,,}" != "xml" ]]; then
		cp "$1" "$1.bak" 2> /dev/null
	fi

	# Backup input file
	if [[ $backup ]] && [[ "$1" == "$inputfilename" ]] && ! [[ -f "$1.bak" ]]; then
		cp "$1" "$1.bak" 2> /dev/null
	fi

	# Detect encoding of input file
	# We use both file and uchardet (if it is available) because no one is perfect.
	# file doesn't get right some non-unicode encodings, but for UTF-16 is preferable
	# than uchardet because the latter doesn't specify if it is UTF-16BE or UTF-16LE.
	# uchardet doesn't exist for Cygwin but does for MinGW. One place you can find a binary is here:
	# https://sourceforge.net/projects/cbadvanced/files/Repo/
	# For chaptedit to be able to use uchardet put uchardet.exe inside /bin directory in the Cygwin installation folder.
	# This uchardet has 2 problems: It needs windows-style path and it produces windows-style line endings.
	# We work around them in chaptedit, but keep them in mind if you use uchardet in the console.
	if [[ $encoding == "utf-16"* ]] || [[ $encoding == *"ascii"* ]]; then
		:
	elif [[ -x /usr/bin/uchardet ]]; then
		cd "$(dirname "$1")"
		encoding=$(uchardet "$(basename "$1")" | tr -d '\r')
		cd - &> /dev/null
	fi

	# If the encoding is detected as ISO-8859-7, make it CP1253
	if [[ ${encoding^^} == "ISO-8859-7" ]]; then
		encoding="CP1253"
	fi

	# If text file is UTF-16 convert it to UTF-8
	if [[ $encoding == "utf-16"* ]]; then
		tempvar="$(cat "$1" | iconv -f $encoding -t utf-8)"
		printf "%s\n" "$tempvar" > "$1"
		encoding="utf-8"
		unset tempvar
	fi
}


read_txt ()
{
	# Make all line endings dos-like
	dos2unix -q "$1" 2> /dev/null
	temptext=$(cat "$1")
	echo "$temptext" | tr '\r' '\n' > "$1"
	unix2dos -q "$1" 2> /dev/null

	# Read text file to a temp array
	old_IFS=$IFS		# save the field separator
	IFS=$'\n'			# new field separator, the end of line

	temp0array=()
	for line in $(iconv -f $encoding -t utf-8 "$1" 2> /dev/null); do
		if ! [[ $line =~ $regexemptyline ]]; then
			temp0array+=($line)
		fi
	done

	# Check if the file is ogm (txt) or xml type
	if [[ ${temp0array[0]} =~ $regextime ]]; then
		filetype="txt"
	elif [[ ${temp0array[0]} == "<?xml"* ]]; then
		filetype="xml"
	else
		echo "${red}Error: \"$1\" is not a valid txt file${normal}"
		return 1
	fi

	regexxmltime="<ChapterTimeStart>([0-9][0-9]):([0-9][0-9]):([0-9][0-9])\.([0-9][0-9][0-9])[0-9]*</ChapterTimeStart>"
	regexxmlname="<ChapterString>(.*)</ChapterString>"

	# Create an assosiative array. At the same time remove duplicate chapters and create a chapter name if it doesn't exist
	unset chaptdict
	declare -A chaptdict
	if [[ $filetype == "txt" ]]; then
		temp1arraytxt=()
		for ((i=0; i<=${#temp0array[@]}; i++)); do
			line=${temp0array[$i]}
			if [[ $line =~ $regextime ]] || [[ $line =~ $regexname ]]; then
				temp1arraytxt+=($line)
			fi
		done

		for ((i=0; i<=${#temp1arraytxt[@]}; i++)); do
			if [[ ${temp1arraytxt[$i]} =~ $regextime ]]; then
				index="${BASH_REMATCH[1]}"
				time="${BASH_REMATCH[2]}:${BASH_REMATCH[3]}:${BASH_REMATCH[4]}.${BASH_REMATCH[5]}"

				if [[ ${temp1arraytxt[((i+1))]} =~ $regexname ]]; then
					index_name="${BASH_REMATCH[1]}"
					name="${BASH_REMATCH[2]}"
				else
					index_name=$index
					name=""
				fi

				if (( 10#$index == 10#$index_name )); then
					chaptdict[$time]=$name
				else
					echo "${red}Error: \"$1\" is not a valid chapters file. The problem is in chapter $index.${normal}"
					return 1
				fi
			fi
		done
	elif [[ $filetype == "xml" ]]; then
		temp1arraytxt=()
		for ((i=0; i<=${#temp0array[@]}; i++)); do
			line=${temp0array[$i]}
			if [[ $line =~ $regexxmltime ]] || [[ $line =~ $regexxmlname ]]; then
				temp1arraytxt+=($line)
			fi
		done

		for ((i=0; i<=${#temp1arraytxt[@]}; i++)); do
			if [[ ${temp1arraytxt[$i]} =~ $regexxmltime ]]; then
				time="${BASH_REMATCH[1]}:${BASH_REMATCH[2]}:${BASH_REMATCH[3]}.${BASH_REMATCH[4]}"

				if [[ ${temp1arraytxt[((i+1))]} =~ $regexxmlname ]]; then
					name="${BASH_REMATCH[1]}"
				else
					name=""
				fi

				chaptdict[$time]=$name
			fi
		done
	fi


	# Create the arraytxt
	temp2arraytxt=()
	chaptcounter=1
	for i in $(printf "%s\n" "${!chaptdict[@]}" | sort); do
		zero=""
		if ((chaptcounter < 10)); then zero=0; fi

		temp2arraytxt+=("CHAPTER$zero$chaptcounter=$i$cr")
		temp2arraytxt+=("CHAPTER$zero${chaptcounter}NAME=${chaptdict[$i]}$cr")

		((chaptcounter++))
	done

	arraytxt=()
	arraytxt=( $(printf "%s\n" "${temp2arraytxt[@]}" | iconv -f utf-8 -t $encoding) )

	IFS=$old_IFS		# restore default field separator
}


check_txt ()
{
	# Check the file extension
	extension="${1##*.}"
	if [[ "${extension,,}" != "txt" ]] && [[ "${extension,,}" != "ogm" ]] && [[ "${extension,,}" != "xml" ]]; then
		echo "${bold}${red}Warning: \"$1\" does not have '.txt', '.ogm' or '.xml' extension${normal}"
	fi

	txtok=""
	for ((i=0; i<=${#arraytxt[@]}; i++)); do
		if [[ ${arraytxt[$i]} =~ $regextime ]]; then
			if [[ $2 ]]; then echo $2; fi
			txtok="true"
			break
		fi
	done

	if ! [[ $txtok ]]; then
		if ! [[ -r "$1.bak" ]]; then
			echo "${bold}${red}Warning: \"$1.bak\" is not readable${normal}"
		fi
		if [[ $backup ]]; then
			cp "$1.bak" "$1" 2> /dev/null
		else
			mv "$1.bak" "$1" 2> /dev/null
		fi
		echo "${red}Error: \"$1\" is not a valid txt file${normal}"
		return 1
	elif ! [[ $backup ]]; then
		rm -f "$1.bak" 2> /dev/null
	fi
}


### Main functions
basic_clean_up ()
{
	# Check if the input file is a text
	check_file "$inputfilename"

	# Exit this function if the return code of check_file is not 0
	if (($? != 0)); then
		return 1
	fi

	read_txt "$inputfilename"

	# Exit this function if the return code of read_txt is not 0
	if (($? != 0)); then
		return 1
	fi

	# Check if the txt is OK
	check_txt "$inputfilename" "Purifying \"$inputfilename\""

	# Exit this function if the return code of check_txt is not 0
	if (($? != 0)); then
		return 1
	fi

	basename=${inputfilename%.*}
	printf "%s\n" "${arraytxt[@]}" > "${basename}.txt"
}


shift_time ()
{
	# Calculate the time to move the chapters
	regexshift="^([az+-]?)([0-9][0-9]):([0-9][0-9]):([0-9][0-9]),([0-9][0-9][0-9])$"

	if [[ $shifttime =~ $regexshift ]]; then
		sign="${BASH_REMATCH[1]}"
		h="${BASH_REMATCH[2]}"
		m="${BASH_REMATCH[3]}"
		s="${BASH_REMATCH[4]}"
		f="${BASH_REMATCH[5]}"
	else
		echo "${red}Error: Syntax must be like '(+/-/a/z)hh:mm:ss,fff'${normal}"; exit 1
	fi

	if (( 10#$m >= 60 )) || (( 10#$s >= 60 )); then
		echo "${red}Error: Minutes and seconds must take a value of less than 60${normal}"; exit 1
	fi

	givenms=$(($(($((10#$h)) * 3600000)) + $(($((10#$m)) * 60000)) + $(($((10#$s)) * 1000)) + $((10#$f))))


	# Check if the input file is a text
	check_file "$inputfilename"

	# Exit this function if the return code of check_file is not 0
	if (($? != 0)); then
		return 1
	fi

	# Read text file to arraytxt
	read_txt "$inputfilename"

	# Exit this function if the return code of read_txt is not 0
	if (($? != 0)); then
		return 1
	fi

	# Check if the txt is OK
	check_txt "$inputfilename" "Shifting time of \"$inputfilename\" by $shifttime..."

	# Exit this function if the return code of check_txt is not 0
	if (($? != 0)); then
		return 1
	fi


	# Find shift milliseconds
	if [[ $sign == "a" ]]; then
		# Find the first chapter time
		for ((i=0; i<=${#arraytxt[@]}; i++)); do
			line=${arraytxt[$i]}

			if [[ $line =~ $regextime ]]; then
				ha="${BASH_REMATCH[2]}"
				ma="${BASH_REMATCH[3]}"
				sa="${BASH_REMATCH[4]}"
				fa="${BASH_REMATCH[5]}"

				break
			fi
		done

		# Time in milliseconds of the first chapter
		pa=$(($(($((10#$ha)) * 3600000)) + $(($((10#$ma)) * 60000)) + $(($((10#$sa)) * 1000)) + $((10#$fa))))

		# Shift milliseconds
		((p=givenms-pa))
	elif [[ $sign == "z" ]]; then
		# Find the last chapter time
		for ((i=-1; i>=-${#arraytxt[@]}; i--)); do
			line=${arraytxt[$i]}

			if [[ $line =~ $regextime ]]; then
				hb="${BASH_REMATCH[2]}"
				mb="${BASH_REMATCH[3]}"
				sb="${BASH_REMATCH[4]}"
				fb="${BASH_REMATCH[5]}"

				break
			fi
		done

		# Time in milliseconds of the last chapter
		pb=$(($(($((10#$hb)) * 3600000)) + $(($((10#$mb)) * 60000)) + $(($((10#$sb)) * 1000)) + $((10#$fb))))

		# Shift milliseconds
		((p=givenms-pb))
	else
		# Shift milliseconds
		p=$sign$givenms
	fi


	# Process the array
	for ((i=0; i<=${#arraytxt[@]}; i++)); do
		line=${arraytxt[$i]}

		if [[ $line =~ $regextime ]]; then
			chaptcounter1="${BASH_REMATCH[1]}"
			h1="${BASH_REMATCH[2]}"
			m1="${BASH_REMATCH[3]}"
			s1="${BASH_REMATCH[4]}"
			f1="${BASH_REMATCH[5]}"

			p1=$(($(($((10#$h1)) * 3600000)) + $(($((10#$m1)) * 60000)) + $(($((10#$s1)) * 1000)) + $((10#$f1))))

			p1_new=$(($p1 + $p))

			if (( $p1_new < 0 )); then
				echo "${red}Error: Negative time not allowed. Check the shifting value.${normal}"; return 1
			fi

			j1=$(printf "%02d:%02d:%02d.%03d" $(($p1_new / 3600000)) $(($(($p1_new % 3600000)) / 60000)) $(($(($p1_new % 60000)) / 1000)) $(($p1_new % 1000)))

			line_new="CHAPTER$chaptcounter1=$j1"

			arraytxt[$i]=$line_new$cr
		fi
	done

	# Write to the txt file the contents of array.
	basename=${inputfilename%.*}
	printf "%s\n" "${arraytxt[@]}" > "${basename}.txt"
}


change_fps ()
{
	# Check if the input file is a text
	check_file "$inputfilename"

	# Exit this function if the return code of check_file is not 0
	if (($? != 0)); then
		return 1
	fi

	# Read text file to arraytxt
	read_txt "$inputfilename"

	# Exit this function if the return code of read_txt is not 0
	if (($? != 0)); then
		return 1
	fi

	# Check if the txt is OK
	if [[ $pal2ntsc ]]; then
		check_txt "$inputfilename" "Changing fps of \"$inputfilename\" from PAL (25) to NTSC (23.976 or 29.970)..."
	elif [[ $ntsc2pal ]]; then
		check_txt "$inputfilename" "Changing fps of \"$inputfilename\" from NTSC (23.976 or 29.970) to PAL (25)..."
	fi

	# Exit this function if the return code of check_txt is not 0
	if (($? != 0)); then
		return 1
	fi

	# Process the array
	for ((i=0; i<=${#arraytxt[@]}; i++)); do
		line=${arraytxt[$i]}

		if [[ $line =~ $regextime ]]; then
			chaptcounter1="${BASH_REMATCH[1]}"
			h1="${BASH_REMATCH[2]}"
			m1="${BASH_REMATCH[3]}"
			s1="${BASH_REMATCH[4]}"
			f1="${BASH_REMATCH[5]}"

			p1=$(($(($((10#$h1)) * 3600000)) + $(($((10#$m1)) * 60000)) + $(($((10#$s1)) * 1000)) + $((10#$f1))))

			if [[ $pal2ntsc ]]; then
				p1_new=$(($p1 * 1001 / 960))
			elif [[ $ntsc2pal ]]; then
				p1_new=$(($p1 * 960 / 1001))
			fi

			j1=$(printf "%02d:%02d:%02d.%03d" $(($p1_new / 3600000)) $(($(($p1_new % 3600000)) / 60000)) $(($(($p1_new % 60000)) / 1000)) $(($p1_new % 1000)))

			line_new="CHAPTER$chaptcounter1=$j1"

			arraytxt[$i]=$line_new$cr
		fi
	done

	# Write to the txt file the contents of array.
	basename=${inputfilename%.*}
	printf "%s\n" "${arraytxt[@]}" > "${basename}.txt"
}


adjust_time ()
{
	# Calculate the time to move the chapters
	regexadjust="^([+-]?)([0-9][0-9]):([0-9][0-9]):([0-9][0-9]),([0-9][0-9][0-9])$"

	if [[ $adjustfirst =~ $regexadjust ]]; then
		sign="${BASH_REMATCH[1]}"
		h="${BASH_REMATCH[2]}"
		m="${BASH_REMATCH[3]}"
		s="${BASH_REMATCH[4]}"
		f="${BASH_REMATCH[5]}"
	else
		echo "${red}Error: Syntax must be like '(+/-)hh:mm:ss,fff (+/-)hh:mm:ss,fff'${normal}"; exit 1
	fi

	if [[ $adjustlast =~ $regexadjust ]]; then
		sign_="${BASH_REMATCH[1]}"
		h_="${BASH_REMATCH[2]}"
		m_="${BASH_REMATCH[3]}"
		s_="${BASH_REMATCH[4]}"
		f_="${BASH_REMATCH[5]}"
	else
		echo "${red}Error: Syntax must be like '(+/-)hh:mm:ss,fff (+/-)hh:mm:ss,fff'${normal}"; exit 1
	fi

	if (( 10#$m >= 60 )) || (( 10#$s >= 60 )) || (( 10#$m_ >= 60 )) || (( 10#$s_ >= 60 )); then
		echo "${red}Error: Minutes and seconds must take a value of less than 60${normal}"; exit 1
	fi


	# Check if the input file is a text
	check_file "$inputfilename"

	# Exit this function if the return code of check_file is not 0
	if (($? != 0)); then
		return 1
	fi

	# Read text file to arraytxt
	read_txt "$inputfilename"

	# Exit this function if the return code of read_txt is not 0
	if (($? != 0)); then
		return 1
	fi

	# Check if the txt is OK
	check_txt "$inputfilename" "Adjusting time of \"$inputfilename\"..."

	# Exit this function if the return code of check_txt is not 0
	if (($? != 0)); then
		return 1
	fi

	# Check if the file has only 1 chapter
	if ((chaptcounter == 1)); then
		echo "${red}Error: File has only 1 chapter. Use Shift time (-s parameter) instead.${normal}"; return 1
	fi


	# Find the first and last chapter time
	for ((i=0; i<=${#arraytxt[@]}; i++)); do
		line=${arraytxt[$i]}

		if [[ $line =~ $regextime ]]; then
			ha="${BASH_REMATCH[2]}"
			ma="${BASH_REMATCH[3]}"
			sa="${BASH_REMATCH[4]}"
			fa="${BASH_REMATCH[5]}"

			break
		fi
	done

	for ((i=-1; i>=-${#arraytxt[@]}; i--)); do
		line=${arraytxt[$i]}

		if [[ $line =~ $regextime ]]; then
			hb="${BASH_REMATCH[2]}"
			mb="${BASH_REMATCH[3]}"
			sb="${BASH_REMATCH[4]}"
			fb="${BASH_REMATCH[5]}"

			break
		fi
	done

	# Time in milliseconds of the first chapter
	pa=$(($(($((10#$ha)) * 3600000)) + $(($((10#$ma)) * 60000)) + $(($((10#$sa)) * 1000)) + $((10#$fa))))

	# Time in milliseconds of the last chapter
	pb=$(($(($((10#$hb)) * 3600000)) + $(($((10#$mb)) * 60000)) + $(($((10#$sb)) * 1000)) + $((10#$fb))))


	# Calculate the NEW first and last chapter
	if [[ $sign ]]; then
		p=$(($pa $sign $(($(($((10#$h)) * 3600000)) + $(($((10#$m)) * 60000)) + $(($((10#$s)) * 1000)) + $((10#$f))))))
	else
		p=$(($(($((10#$h)) * 3600000)) + $(($((10#$m)) * 60000)) + $(($((10#$s)) * 1000)) + $((10#$f))))
	fi

	if [[ $sign_ ]]; then
		p_=$(($pb $sign_ $(($(($((10#$h_)) * 3600000)) + $(($((10#$m_)) * 60000)) + $(($((10#$s_)) * 1000)) + $((10#$f_))))))
	else
		p_=$(($(($((10#$h_)) * 3600000)) + $(($((10#$m_)) * 60000)) + $(($((10#$s_)) * 1000)) + $((10#$f_))))
	fi


	if (( $pa == $pb )); then
		echo "${red}Error: Cannot process the file. The first chapter is at the same time as the last chapter${normal}"; return 1
	elif (( $pa > $pb )); then
		echo "${red}Error: Cannot process the file. The first chapter is after the last chapter${normal}"; return 1
	fi

	if (( $p == $p_ )); then
		echo "${red}Error: The first chapter cannot be at the same time as the last chapter${normal}"; return 1
	elif (( $p > $p_ )); then
		echo "${red}Error: The first chapter cannot be after the last chapter${normal}"; return 1
	fi


	# Process the array
	diff1=$(($p_ - $p))
	diff2=$(($pb - $pa))

	for ((i=0; i<=${#arraytxt[@]}; i++)); do
		line=${arraytxt[$i]}

		if [[ $line =~ $regextime ]]; then
			chaptcounter1="${BASH_REMATCH[1]}"
			h1="${BASH_REMATCH[2]}"
			m1="${BASH_REMATCH[3]}"
			s1="${BASH_REMATCH[4]}"
			f1="${BASH_REMATCH[5]}"

			p1=$(($(($((10#$h1)) * 3600000)) + $(($((10#$m1)) * 60000)) + $(($((10#$s1)) * 1000)) + $((10#$f1))))

			p1_new=$(($p + $diff1 * (($p1 - $pa)) / $diff2))

			if (( $p1_new < 0 )); then
				echo "${red}Error: Negative time not allowed. Check the adjusting values.${normal}"; return 1
			fi

			j1=$(printf "%02d:%02d:%02d.%03d" $(($p1_new / 3600000)) $(($(($p1_new % 3600000)) / 60000)) $(($(($p1_new % 60000)) / 1000)) $(($p1_new % 1000)))

			line_new="CHAPTER$chaptcounter1=$j1"

			arraytxt[$i]=$line_new$cr
		fi
	done

	# Write to the txt file the contents of array.
	basename=${inputfilename%.*}
	printf "%s\n" "${arraytxt[@]}" > "${basename}.txt"
}


adjust_time_v2 ()
{
	# Check if the input file is a text
	check_file "$inputfilename"

	# Exit this function if the return code of check_file is not 0
	if (($? != 0)); then
		return 1
	fi

	# Read text file to arraytxt
	read_txt "$inputfilename"

	# Exit this function if the return code of read_txt is not 0
	if (($? != 0)); then
		return 1
	fi

	# Check if the txt is OK
	check_txt "$inputfilename" "Adjusting time of \"$inputfilename\"..."

	# Exit this function if the return code of check_txt is not 0
	if (($? != 0)); then
		return 1
	fi

	# Check if the file has only 1 chapter
	if ((chaptcounter == 1)); then
		echo "${red}Error: File has only 1 chapter. Use Shift time (-s parameter) instead.${normal}"; return 1
	fi


	# Find the first and last chapter time
	for ((i=0; i<=${#arraytxt[@]}; i++)); do
		line=${arraytxt[$i]}

		if [[ $line =~ $regextime ]]; then
			ha="${BASH_REMATCH[2]}"
			ma="${BASH_REMATCH[3]}"
			sa="${BASH_REMATCH[4]}"
			fa="${BASH_REMATCH[5]}"

			break
		fi
	done

	for ((i=-1; i>=-${#arraytxt[@]}; i--)); do
		line=${arraytxt[$i]}

		if [[ $line =~ $regextime ]]; then
			hb="${BASH_REMATCH[2]}"
			mb="${BASH_REMATCH[3]}"
			sb="${BASH_REMATCH[4]}"
			fb="${BASH_REMATCH[5]}"

			break
		fi
	done

	if (( 10#$ma >= 60 )) || (( 10#$sa >= 60 )) || (( 10#$mb >= 60 )) || (( 10#$sb >= 60 )); then
		echo "${red}Error: The first or last chapter time is invalid.${normal}"; return 1
	fi

	# Time in milliseconds of the first chapter
	pa=$(($(($((10#$ha)) * 3600000)) + $(($((10#$ma)) * 60000)) + $(($((10#$sa)) * 1000)) + $((10#$fa))))

	# Time in milliseconds of the last chapter
	pb=$(($(($((10#$hb)) * 3600000)) + $(($((10#$mb)) * 60000)) + $(($((10#$sb)) * 1000)) + $((10#$fb))))


	# Calculate the time to move the chapters
	regexadjust="^([+-]?)([0-9][0-9]):([0-9][0-9]):([0-9][0-9]),([0-9][0-9][0-9])$"

	if ! [[ $adjustonlyfirst ]]; then
		h=$ha
		m=$ma
		s=$sa
		f=$fa
	elif [[ $adjustonlyfirst =~ $regexadjust ]]; then
		sign="${BASH_REMATCH[1]}"
		h="${BASH_REMATCH[2]}"
		m="${BASH_REMATCH[3]}"
		s="${BASH_REMATCH[4]}"
		f="${BASH_REMATCH[5]}"
	else
		echo "${red}Error: Syntax must be like '(+/-)hh:mm:ss,fff'${normal}"; exit 1
	fi

	if ! [[ $adjustonlylast ]]; then
		h_=$hb
		m_=$mb
		s_=$sb
		f_=$fb
	elif [[ $adjustonlylast =~ $regexadjust ]]; then
		sign_="${BASH_REMATCH[1]}"
		h_="${BASH_REMATCH[2]}"
		m_="${BASH_REMATCH[3]}"
		s_="${BASH_REMATCH[4]}"
		f_="${BASH_REMATCH[5]}"
	else
		echo "${red}Error: Syntax must be like '(+/-)hh:mm:ss,fff'${normal}"; exit 1
	fi

	if (( 10#$m >= 60 )) || (( 10#$s >= 60 )) || (( 10#$m_ >= 60 )) || (( 10#$s_ >= 60 )); then
		echo "${red}Error: Minutes and seconds must take a value of less than 60${normal}"; exit 1
	fi


	# Calculate the NEW first and last chapter
	if [[ $sign ]]; then
		p=$(($pa $sign $(($(($((10#$h)) * 3600000)) + $(($((10#$m)) * 60000)) + $(($((10#$s)) * 1000)) + $((10#$f))))))
	else
		p=$(($(($((10#$h)) * 3600000)) + $(($((10#$m)) * 60000)) + $(($((10#$s)) * 1000)) + $((10#$f))))
	fi

	if [[ $sign_ ]]; then
		p_=$(($pb $sign_ $(($(($((10#$h_)) * 3600000)) + $(($((10#$m_)) * 60000)) + $(($((10#$s_)) * 1000)) + $((10#$f_))))))
	else
		p_=$(($(($((10#$h_)) * 3600000)) + $(($((10#$m_)) * 60000)) + $(($((10#$s_)) * 1000)) + $((10#$f_))))
	fi


	if (( $pa == $pb )); then
		echo "${red}Error: Cannot process the file. The first chapter is at the same time as the last chapter${normal}"; return 1
	elif (( $pa > $pb )); then
		echo "${red}Error: Cannot process the file. The first chapter is after the last chapter${normal}"; return 1
	fi

	if (( $p == $p_ )); then
		echo "${red}Error: The first chapter cannot be at the same time as the last chapter${normal}"; return 1
	elif (( $p > $p_ )); then
		echo "${red}Error: The first chapter cannot be after the last chapter${normal}"; return 1
	fi


	# Process the array
	diff1=$(($p_ - $p))
	diff2=$(($pb - $pa))

	for ((i=0; i<=${#arraytxt[@]}; i++)); do
		line=${arraytxt[$i]}

		if [[ $line =~ $regextime ]]; then
			chaptcounter1="${BASH_REMATCH[1]}"
			h1="${BASH_REMATCH[2]}"
			m1="${BASH_REMATCH[3]}"
			s1="${BASH_REMATCH[4]}"
			f1="${BASH_REMATCH[5]}"

			p1=$(($(($((10#$h1)) * 3600000)) + $(($((10#$m1)) * 60000)) + $(($((10#$s1)) * 1000)) + $((10#$f1))))

			p1_new=$(($p + $diff1 * (($p1 - $pa)) / $diff2))

			if (( $p1_new < 0 )); then
				echo "${red}Error: Negative time not allowed. Check the adjusting values.${normal}"; return 1
			fi

			j1=$(printf "%02d:%02d:%02d.%03d" $(($p1_new / 3600000)) $(($(($p1_new % 3600000)) / 60000)) $(($(($p1_new % 60000)) / 1000)) $(($p1_new % 1000)))

			line_new="CHAPTER$chaptcounter1=$j1"

			arraytxt[$i]=$line_new$cr
		fi
	done

	# Write to the txt file the contents of array.
	basename=${inputfilename%.*}
	printf "%s\n" "${arraytxt[@]}" > "${basename}.txt"
}


synchronize_with_file ()
{
	if [[ $synchronizedirectory ]]; then
		synchronizefile="$synchronizedirectory/$(basename "$inputfilename")"
		if ! [[ -f "$synchronizefile" ]]; then
			echo "${red}Error: \"$synchronizefile\" not found.${normal}"
			return 1
		fi

		if ! [[ -r "$synchronizefile" ]]; then
			echo "${red}Error: \"$synchronizefile\" is not readable.${normal}"
			return 1
		fi
	fi

	# Check if the synchronize file is a text
	check_file "$synchronizefile"

	# Exit this function if the return code of check_file is not 0
	if (($? != 0)); then
		return 1
	fi

	# Read file to synchronize to
	read_txt "$synchronizefile"

	# Exit this function if the return code of read_txt is not 0
	if (($? != 0)); then
		return 1
	fi

	# Check if the txt is OK
	check_txt "$synchronizefile"

	# Exit this function if the return code of check_txt is not 0
	if (($? != 0)); then
		return 1
	fi

	if ! [[ $synchronizetimebytime ]]; then
		# Find the first and last chapter time of the file to synchronize to
		for ((i=0; i<=${#arraytxt[@]}; i++)); do
			line=${arraytxt[$i]}

			if [[ $line =~ $regextime ]]; then
				h="${BASH_REMATCH[2]}"
				m="${BASH_REMATCH[3]}"
				s="${BASH_REMATCH[4]}"
				f="${BASH_REMATCH[5]}"

				break
			fi
		done

		for ((i=-1; i>=-${#arraytxt[@]}; i--)); do
			line=${arraytxt[$i]}

			if [[ $line =~ $regextime ]]; then
				h_="${BASH_REMATCH[2]}"
				m_="${BASH_REMATCH[3]}"
				s_="${BASH_REMATCH[4]}"
				f_="${BASH_REMATCH[5]}"

				break
			fi
		done

		if (( 10#$m >= 60 )) || (( 10#$s >= 60 )) || (( 10#$m_ >= 60 )) || (( 10#$s_ >= 60 )); then
			echo "${red}Error: The first or last chapter time of the chapters file you want to synchronize with, is invalid.${normal}"; return 1
		fi

		# Calculate the NEW first and last chapter
		p=$(($(($((10#$h)) * 3600000)) + $(($((10#$m)) * 60000)) + $(($((10#$s)) * 1000)) + $((10#$f))))
		p_=$(($(($((10#$h_)) * 3600000)) + $(($((10#$m_)) * 60000)) + $(($((10#$s_)) * 1000)) + $((10#$f_))))

		if (( $p == $p_ )); then
			echo "${red}Error: The first chapter cannot be at the same time as the last chapter${normal}"; return 1
		elif (( $p > $p_ )); then
			echo "${red}Error: The first chapter cannot be after the last chapter${normal}"; return 1
		fi


		# Check if the input file is a text
		check_file "$inputfilename"

		# Exit this function if the return code of check_file is not 0
		if (($? != 0)); then
			return 1
		fi

		# Read text file to arraytxt
		read_txt "$inputfilename"

		# Exit this function if the return code of read_txt is not 0
		if (($? != 0)); then
			return 1
		fi

		# Check if the txt is OK
		check_txt "$inputfilename" "Synchronizing \"$inputfilename\" with \"$synchronizefile\"..."

		# Exit this function if the return code of check_txt is not 0
		if (($? != 0)); then
			return 1
		fi

		# Check if the file has only 1 chapter
		if ((chaptcounter == 1)); then
			echo "${red}Error: File has only 1 chapter. Use Shift time (-s parameter) instead.${normal}"; return 1
		fi


		# Find the first and last chapter time
		for ((i=0; i<=${#arraytxt[@]}; i++)); do
			line=${arraytxt[$i]}

			if [[ $line =~ $regextime ]]; then
				ha="${BASH_REMATCH[2]}"
				ma="${BASH_REMATCH[3]}"
				sa="${BASH_REMATCH[4]}"
				fa="${BASH_REMATCH[5]}"

				break
			fi
		done

		for ((i=-1; i>=-${#arraytxt[@]}; i--)); do
			line=${arraytxt[$i]}

			if [[ $line =~ $regextime ]]; then
				hb="${BASH_REMATCH[2]}"
				mb="${BASH_REMATCH[3]}"
				sb="${BASH_REMATCH[4]}"
				fb="${BASH_REMATCH[5]}"

				break
			fi
		done

		# Time in milliseconds of the first chapter
		pa=$(($(($((10#$ha)) * 3600000)) + $(($((10#$ma)) * 60000)) + $(($((10#$sa)) * 1000)) + $((10#$fa))))

		# Time in milliseconds of the last chapter
		pb=$(($(($((10#$hb)) * 3600000)) + $(($((10#$mb)) * 60000)) + $(($((10#$sb)) * 1000)) + $((10#$fb))))

		if (( $pa == $pb )); then
			echo "${red}Error: Cannot process the file. The first chapter is at the same time as the last chapter${normal}"; return 
		elif (( $pa > $pb )); then
			echo "${red}Error: Cannot process the file. The first chapter is after the last chapter${normal}"; return 1
		fi


		# Process the array
		diff1=$(($p_ - $p))
		diff2=$(($pb - $pa))

		for ((i=0; i<=${#arraytxt[@]}; i++)); do
			line=${arraytxt[$i]}

			if [[ $line =~ $regextime ]]; then
				chaptcounter1="${BASH_REMATCH[1]}"
				h1="${BASH_REMATCH[2]}"
				m1="${BASH_REMATCH[3]}"
				s1="${BASH_REMATCH[4]}"
				f1="${BASH_REMATCH[5]}"

				p1=$(($(($((10#$h1)) * 3600000)) + $(($((10#$m1)) * 60000)) + $(($((10#$s1)) * 1000)) + $((10#$f1))))

				p1_new=$(($p + $diff1 * (($p1 - $pa)) / $diff2))

				if (( $p1_new < 0 )); then
					echo "${red}Error: Negative time not allowed. Check the adjusting values.${normal}"; return 1
				fi

				j1=$(printf "%02d:%02d:%02d.%03d" $(($p1_new / 3600000)) $(($(($p1_new % 3600000)) / 60000)) $(($(($p1_new % 60000)) / 1000)) $(($p1_new % 1000)))

				line_new="CHAPTER$chaptcounter1=$j1"

				arraytxt[$i]=$line_new$cr
			fi
		done
	else
		# Copy the times of arraytxt to arraysynchronize
		arraysynchronize=()

		for ((i=0; i<=${#arraytxt[@]}; i++)); do
			if [[ ${arraytxt[$i]} =~ $regextime ]]; then
				arraysynchronize+=("${arraytxt[$i]}")
			fi
		done

		# Check if the input file is a text
		check_file "$inputfilename"

		# Exit this function if the return code of check_file is not 0
		if (($? != 0)); then
			return 1
		fi

		# Read text file to arraytxt
		read_txt "$inputfilename"

		# Exit this function if the return code of read_txt is not 0
		if (($? != 0)); then
			return 1
		fi

		# Check if the txt is OK
		check_txt "$inputfilename" "Synchronizing \"$inputfilename\" with \"$synchronizefile\"..."

		# Exit this function if the return code of check_txt is not 0
		if (($? != 0)); then
			return 1
		fi

		counter=0
		for ((i=0; i<=${#arraytxt[@]}; i++)); do
			if [[ ${arraytxt[$i]} =~ $regextime ]]; then
				if [[ ${arraysynchronize[$counter]} ]]; then
					arraytxt[$i]="${arraysynchronize[$counter]}"
					((counter++))
				else
					break
				fi
			fi
		done
	fi

	# Write to the txt file the contents of array.
	basename=${inputfilename%.*}
	printf "%s\n" "${arraytxt[@]}" > "${basename}.txt"
}


find_text ()
{
	# Check if the input file is a text
	check_file "$inputfilename"

	# Exit this function if the return code of check_file is not 0
	if (($? != 0)); then
		return 1
	fi

	if [[ $findci ]]; then
		find=$findci
	elif [[ $findcs ]]; then
		find=$findcs
	fi

	echo -e "Finding \"$find\" in file \"$inputfilename\""

	# Exit this function if the return code of check_txt is not 0
	if (($? != 0)); then
		return 1
	fi

	old_IFS=$IFS		# save the field separator
	IFS=$'\n'			# new field separator, the end of line

	if [[ $findci ]]; then
		iconv -f $encoding -t utf-8 "$inputfilename" 2> /dev/null | grep $find -ni | sed s'/:/: /' | while read -r line; do echo "line $line"; done
	else
		iconv -f $encoding -t utf-8 "$inputfilename" 2> /dev/null | grep $find -n | sed s'/:/: /' | while read -r line; do echo "line $line"; done
	fi

	IFS=$old_IFS		# restore default field separator
}


replace_text ()
{
	# Check if the input file is a text
	check_file "$inputfilename"

	# Exit this function if the return code of check_file is not 0
	if (($? != 0)); then
		return 1
	fi

	if [[ $replace3 ]]; then
		replace1=$replace3
		replace2=$replace4
	fi

	# Define forbidden and allowed regex
	regexforbiddensynbols="^[0-9<>\/:\$=#-,]+$"
	regexallowedtimes="^[0-9][0-9]:[0-9][0-9]:[0-9][0-9],[0-9][0-9][0-9] --> [0-9][0-9]:[0-9][0-9]:[0-9][0-9],[0-9][0-9][0-9]$"
	regexallowedtime="^[0-9][0-9]:[0-9][0-9]:[0-9][0-9],[0-9][0-9][0-9]$"
	
	if ! [[  $replace1 =~  $regexallowedtimes ]] && ! [[  $replace1 =~  $regexallowedframes ]] && ! [[  $replace1 =~  $regexallowedtime ]] && ! [[  $replace1 =~  $regexallowedframe ]] && [[ $replace1 =~ $regexforbiddensynbols ]]; then
		echo "${red}Error: You cannot replace this${normal}"; exit 1
	fi

	IFS=$'\n'			# new field separator, the end of line

	if [[ $replace3 ]]; then
		read_txt "$inputfilename"

		# Exit this function if the return code of read_txt is not 0
		if (($? != 0)); then
			return 1
		fi

		temparray=( $(printf "%s\n" "${arraytxt[@]}" | iconv -f $encoding -t utf-8 | sed -b s"/$replace1/$replace2/g") )
		# If the conversion from UTF-8 to the original encoding isn't possible, keep the UTF-8
		printf "%s\n" "${temparray[@]}" | iconv -f utf-8 -t $encoding &> /dev/null
		if (($? == 0)); then
			basename=${inputfilename%.*}
			printf "%s\n" "${temparray[@]}" | iconv -f utf-8 -t $encoding > "${basename}.txt"
		else
			basename=${inputfilename%.*}
			printf "%s\n" "${temparray[@]}" > "${basename}.txt"
			echo "${bold}${red}Warning: \"${basename}.txt\" has been saved with UTF-8 encoding${normal}"
		fi
		unset temparray
	else
		read_txt "$inputfilename"

		# Exit this function if the return code of read_txt is not 0
		if (($? != 0)); then
			return 1
		fi

		temparray=( $(printf "%s\n" "${arraytxt[@]}" | iconv -f $encoding -t utf-8 | sed -b s"/$replace1/$replace2/ig") )
		# If the conversion from UTF-8 to the original encoding isn't possible, keep the UTF-8
		printf "%s\n" "${temparray[@]}" | iconv -f utf-8 -t $encoding &> /dev/null
		if (($? == 0)); then
			basename=${inputfilename%.*}
			printf "%s\n" "${temparray[@]}" | iconv -f utf-8 -t $encoding > "${basename}.txt"
		else
			basename=${inputfilename%.*}
			printf "%s\n" "${temparray[@]}" > "${basename}.txt"
			echo "${bold}${red}Warning: \"${basename}.txt\" has been saved with UTF-8 encoding${normal}"
		fi
		unset temparray
	fi


	# Check if the txt is OK
	check_txt "$inputfilename" "Replacing \"$replace1\" with \"$replace2\" in file \"$inputfilename\""

	# Exit this function if the return code of check_txt is not 0
	if (($? != 0)); then
		return 1
	fi

	IFS=$old_IFS		# restore default field separator
}


join_txt ()
{
	# Check if the input file is a text
	check_file "$jointxt"

	# Exit this function if the return code of check_file is not 0
	if (($? != 0)); then
		return 1
	fi

	# Encoding of the join file
	encodingjoin=$encoding

	# Read text file to arraytxt
	read_txt "$jointxt"

	# Exit this function if the return code of read_txt is not 0
	if (($? != 0)); then
		return 1
	fi

	# Check if the txt is OK
	check_txt "$jointxt"

	# Exit this function if the return code of check_txt is not 0
	if (($? != 0)); then
		return 1
	fi

	# Create arraytxtjoin from arraytxt
	arraytxtjoin+=("${arraytxt[@]}")


	# Check if the input file is a text
	check_file "$inputfilename"

	# Exit this function if the return code of check_file is not 0
	if (($? != 0)); then
		return 1
	fi

	# Encoding of the input file
	encodinginput=$encoding

	# Read text file to arraytxt
	read_txt "$inputfilename"

	# Exit this function if the return code of read_txt is not 0
	if (($? != 0)); then
		return 1
	fi

	# Check if the txt is OK
	check_txt "$inputfilename"

	# Exit this function if the return code of check_txt is not 0
	if (($? != 0)); then
		return 1
	fi


	# Compare the encodings of the two files and convert to UTF-8 if necessary
	if [[ ${encodinginput,,} != ${encodingjoin,,} ]]; then
		IFS=$'\n'
		echo "${bold}${red}Warning: The two files have different encodings (${encodinginput^^} and ${encodingjoin^^}). The output file will be UTF-8.${normal}"
		if [[ ${encodinginput,,} != "utf-8" ]]; then
			temparraytxt=( $(printf "%s\n" "${arraytxt[@]}" | iconv -f $encodinginput -t utf-8) )
			unset arraytxt
			arraytxt+=("${temparraytxt[@]}")
			unset temparraytxt
		fi

		if [[ ${encodingjoin,,} != "utf-8" ]]; then
			temparraytxtjoin=( $(printf "%s\n" "${arraytxtjoin[@]}" | iconv -f $encodingjoin -t utf-8) )
			unset arraytxtjoin
			arraytxtjoin+=("${temparraytxtjoin[@]}")
			unset temparraytxtjoin
		fi
		IFS=$old_IFS
	fi


	# Add an empty line
	arraytxt+=("$cr")

	if ! [[ $jointime ]]; then
		echo "Joining \"$inputfilename\" with \"$jointxt\"..."
		# Re-create the second chapters file array with new counter
		for ((i=0; i<=${#arraytxtjoin[@]}; i++)); do
			if [[ ${arraytxtjoin[$((i+1))]} =~ $regextime ]] && [[ ${arraytxtjoin[$i]} =~ $regexinteger ]]; then
				((chaptcounter++))
				arraytxtjoin[$i]="$chaptcounter$cr"
			fi
		done
	else
		# Calculate the time of the last chapter of the first file
		for ((i=-1; i>=-${#arraytxt[@]}; i--)); do
			line=${arraytxt[$i]}

			if [[ $line =~ $regextime ]]; then
				hb="${BASH_REMATCH[2]}"
				mb="${BASH_REMATCH[3]}"
				sb="${BASH_REMATCH[4]}"
				fb="${BASH_REMATCH[5]}"

				break
			fi
		done

		# Time in milliseconds of the last chapter of the first file
		pb=$(($(($((10#$hb)) * 3600000)) + $(($((10#$mb)) * 60000)) + $(($((10#$sb)) * 1000)) + $((10#$fb))))


		# Calculate the time to shift the second chapters file
		regexjoin="^([0-9][0-9]):([0-9][0-9]):([0-9][0-9]),([0-9][0-9][0-9])$"

		if [[ $jointime =~ $regexjoin ]]; then
			h="${BASH_REMATCH[1]}"
			m="${BASH_REMATCH[2]}"
			s="${BASH_REMATCH[3]}"
			f="${BASH_REMATCH[4]}"
		else
			echo "${red}Error: Syntax must be like 'hh:mm:ss,fff'${normal}"; exit 1
		fi

		if (( 10#$m >= 60 )) || (( 10#$s >= 60 )); then
			echo "${red}Error: Minutes and seconds must take a value of less than 60${normal}"; exit 1
		fi

		# Time in milliseconds of jointime
		p=$(($(($((10#$h)) * 3600000)) + $(($((10#$m)) * 60000)) + $(($((10#$s)) * 1000)) + $((10#$f))))


		# Compare jointime with the time of the last chapter of the first file
		if ((p < pb)); then
			echo "${red}Error: The duration of the first video (-J parameter) cannot be less than the first chapters file${normal}"; exit 1
		else
			echo "Joining \"$inputfilename\" with \"$jointxt\"..."
		fi


		# Process the array of the second chapters file
		for ((i=0; i<=${#arraytxtjoin[@]}; i++)); do
			line=${arraytxtjoin[$i]}

			if [[ $line =~ $regextime ]]; then
				chaptcounter1="${BASH_REMATCH[1]}"
				h1="${BASH_REMATCH[2]}"
				m1="${BASH_REMATCH[3]}"
				s1="${BASH_REMATCH[4]}"
				f1="${BASH_REMATCH[5]}"

				p1=$(($(($((10#$h1)) * 3600000)) + $(($((10#$m1)) * 60000)) + $(($((10#$s1)) * 1000)) + $((10#$f1))))

				p1_new=$(($p1 + $p))

				j1=$(printf "%02d:%02d:%02d.%03d" $(($p1_new / 3600000)) $(($(($p1_new % 3600000)) / 60000)) $(($(($p1_new % 60000)) / 1000)) $(($p1_new % 1000)))

				line_new="CHAPTER$chaptcounter1=$j1"

				arraytxtjoin[$i]=$line_new
			fi
		done

		# Re-create the second chapters file array with new counter
		for ((i=0; i<=${#arraytxtjoin[@]}; i++)); do
			if [[ ${arraytxtjoin[$((i+1))]} =~ $regextime ]] && [[ ${arraytxtjoin[$i]} =~ $regexinteger ]]; then
				((chaptcounter++))
				arraytxtjoin[$i]="$chaptcounter$cr"
			fi
		done
	fi


	# Add the second array to the first
	arraytxt+=("${arraytxtjoin[@]}")

	# Write to the txt file the contents of array.
	basename=${inputfilename%.*}
	j="_join.txt"
	printf "%s\n" "${arraytxt[@]}" > "$basename$j"
}


split_txt ()
{
	# Check if the input file is a text
	check_file "$inputfilename"

	# Exit this function if the return code of check_file is not 0
	if (($? != 0)); then
		return 1
	fi

	# Read text file to arraytxt
	read_txt "$inputfilename"

	# Exit this function if the return code of read_txt is not 0
	if (($? != 0)); then
		return 1
	fi

	# Check if the txt is OK
	check_txt "$inputfilename" "Splitting \"$inputfilename\"..."

	# Exit this function if the return code of check_txt is not 0
	if (($? != 0)); then
		return 1
	fi

	# Find the first and last chapter time
	for ((i=0; i<=${#arraytxt[@]}; i++)); do
		line=${arraytxt[$i]}

		if [[ $line =~ $regextime ]]; then
			ha="${BASH_REMATCH[2]}"
			ma="${BASH_REMATCH[3]}"
			sa="${BASH_REMATCH[4]}"
			fa="${BASH_REMATCH[5]}"

			break
		fi
	done

	for ((i=-1; i>=-${#arraytxt[@]}; i--)); do
		line=${arraytxt[$i]}

		if [[ $line =~ $regextime ]]; then
			hb="${BASH_REMATCH[2]}"
			mb="${BASH_REMATCH[3]}"
			sb="${BASH_REMATCH[4]}"
			fb="${BASH_REMATCH[5]}"

			break
		fi
	done

	# Time in milliseconds of the first chapter
	pa=$(($(($((10#$ha)) * 3600000)) + $(($((10#$ma)) * 60000)) + $(($((10#$sa)) * 1000)) + $((10#$fa))))

	# Time in milliseconds of the last chapter
	pb=$(($(($((10#$hb)) * 3600000)) + $(($((10#$mb)) * 60000)) + $(($((10#$sb)) * 1000)) + $((10#$fb))))


	# Initialize the variables
	splitchaptfound=""
	split2counter=0
	arraytxtsplit1=()
	arraytxtsplit2=()

	# Calculate the time to split the chapters file
	regexsplit1="^([+-]?)([0-9][0-9]):([0-9][0-9]):([0-9][0-9]),([0-9][0-9][0-9])$"
	regexsplit2="^([+-]?)([0-9]+)$"
	regexsplit3="^([+-]?)([0-9]+)[:]([0-9]+)[t]$"
	regexsplit4="^([+-]?)([0-9]+)[:]([0-9]+)[n]$"

	if [[ $splittxt =~ $regexsplit1 ]]; then
		sign="${BASH_REMATCH[1]}"
		h="${BASH_REMATCH[2]}"
		m="${BASH_REMATCH[3]}"
		s="${BASH_REMATCH[4]}"
		f="${BASH_REMATCH[5]}"

		if (( 10#$m >= 60 )) || (( 10#$s >= 60 )); then
			echo "${red}Error: Minutes and seconds must take a value of less than 60${normal}"; exit 1
		fi

		# Time in milliseconds to split the chapters file
		p=$(($(($((10#$h)) * 3600000)) + $(($((10#$m)) * 60000)) + $(($((10#$s)) * 1000)) + $((10#$f))))
		if [[ $sign == "-" ]]; then
			p=$(($pb - $p))
		fi

		if ((p < pa)); then
			echo "${red}Error: Split time cannot be shorter than the first chapter time.${normal}"; return 1
		fi

		if ((p > pb)); then
			echo "${red}Error: Split time cannot exceed the duration of the chapters file.${normal}"; return 1
		fi

		# Find the chapter to make the split
		for ((i=0; i<=${#arraytxt[@]}-1; i++)); do
			line=${arraytxt[$i]}
			nextline=${arraytxt[((i+1))]}

			if ! [[ $splitchaptfound ]] && [[ $nextline =~ $regextime ]]; then
				h1="${BASH_REMATCH[2]}"
				m1="${BASH_REMATCH[3]}"
				s1="${BASH_REMATCH[4]}"
				f1="${BASH_REMATCH[5]}"

				p1=$(($(($((10#$h1)) * 3600000)) + $(($((10#$m1)) * 60000)) + $(($((10#$s1)) * 1000)) + $((10#$f1))))

				if ((p1 >= p)); then
					splitchaptfound="True"
				fi
			fi

			if ! [[ $splitchaptfound ]]; then
				arraytxtsplit1[$i]=$line
			else
				arraytxtsplit2[$split2counter]=$line
				((split2counter++))
			fi
		done
	elif [[ $splittxt =~ $regexsplit2 ]]; then
		sign="${BASH_REMATCH[1]}"
		splitinteger="${BASH_REMATCH[2]}"

		if [[ $sign == "-" ]]; then
			splitinteger=$(($chaptcounter - $splitinteger))
		fi

		# Check if the given integer is OK
		if ((splitinteger == 0)) || ((splitinteger > ((chaptcounter-1)))); then
			echo "${red}Error: The number of chapters in the file are $chaptcounter. The given integer must be between or equal to 1 and $((chaptcounter-1)).${normal}"; return 1
		fi

		# Create the two new chapter arrays
		for ((i=0; i<=${#arraytxt[@]}-1; i++)); do
			line=${arraytxt[$i]}
			nextline=${arraytxt[((i+1))]}

			if ! [[ $splitchaptfound ]] && [[ $nextline =~ $regextime ]] && [[ $line =~ $regexinteger ]]; then
				if ((${BASH_REMATCH[1]} > splitinteger)); then
					splitchaptfound="True"
				fi
			fi

			if ! [[ $splitchaptfound ]]; then
				arraytxtsplit1[$i]=$line
			else
				arraytxtsplit2[$split2counter]=$line
				((split2counter++))
			fi
		done
	elif [[ $splittxt =~ $regexsplit3 ]]; then
		sign="${BASH_REMATCH[1]}"
		numerator="${BASH_REMATCH[2]}"
		denominator="${BASH_REMATCH[3]}"

		if ((numerator == 0)) || ((denominator == 0)) || ((numerator >= denominator)); then
			echo "${red}Error: The numerator must be less than the denominator and both must not be 0.${normal}"; exit 1
		fi

		# Time in milliseconds to split the chapters file
		if [[ $sign == "-" ]]; then
			p=$((pb*((denominator - numerator))/denominator))
		else
			p=$((pb*numerator/denominator))
		fi

		if ((p < pa)); then
			echo "${red}Error: Split time cannot be shorter than the first chapter time.${normal}"; return 1
		fi

		# Find the chapter to make the split
		for ((i=0; i<=${#arraytxt[@]}-1; i++)); do
			line=${arraytxt[$i]}
			nextline=${arraytxt[((i+1))]}

			if ! [[ $splitchaptfound ]] && [[ $nextline =~ $regextime ]]; then
				h1="${BASH_REMATCH[2]}"
				m1="${BASH_REMATCH[3]}"
				s1="${BASH_REMATCH[4]}"
				f1="${BASH_REMATCH[5]}"

				p1=$(($(($((10#$h1)) * 3600000)) + $(($((10#$m1)) * 60000)) + $(($((10#$s1)) * 1000)) + $((10#$f1))))

				if ((p1 >= p)); then
					splitchaptfound="True"
				fi
			fi

			if ! [[ $splitchaptfound ]]; then
				arraytxtsplit1[$i]=$line
			else
				arraytxtsplit2[$split2counter]=$line
				((split2counter++))
			fi
		done
	elif [[ $splittxt =~ $regexsplit4 ]]; then
		sign="${BASH_REMATCH[1]}"
		numerator="${BASH_REMATCH[2]}"
		denominator="${BASH_REMATCH[3]}"

		if ((numerator == 0)) || ((denominator == 0)) || ((numerator >= denominator)); then
			echo "${red}Error: The numerator must be less than the denominator and both must not be 0.${normal}"; exit 1
		fi

		if [[ $sign == "-" ]]; then
			if ((chaptcounter%2 == 1)) && ((denominator/numerator == 2)); then
				splitinteger=$((1 + chaptcounter*((denominator - numerator))/denominator))
			else
				splitinteger=$((chaptcounter*((denominator - numerator))/denominator))
			fi
		else
			if ((chaptcounter%2 == 1)) && ((denominator/numerator == 2)); then
				splitinteger=$((1 + chaptcounter*numerator/denominator))
			else
				splitinteger=$((chaptcounter*numerator/denominator))
			fi
		fi

		# Check if the integer is OK
		if ((splitinteger == 0)); then
			echo "${red}Error: The fraction is too small. Exiting...${normal}"; exit 1
		fi

		# Create the two new chapter arrays
		for ((i=0; i<=${#arraytxt[@]}-1; i++)); do
			line=${arraytxt[$i]}
			nextline=${arraytxt[((i+1))]}

			if ! [[ $splitchaptfound ]] && [[ $nextline =~ $regextime ]] && [[ $line =~ $regexinteger ]]; then
				if ((${BASH_REMATCH[1]} > splitinteger)); then
					splitchaptfound="True"
				fi
			fi

			if ! [[ $splitchaptfound ]]; then
				arraytxtsplit1[$i]=$line
			else
				arraytxtsplit2[$split2counter]=$line
				((split2counter++))
			fi
		done
	else
		echo "${red}Error: Syntax must be like '(+/-)hh:mm:ss,fff' or '(+/-)CHAPT_INTEGER' or '(+/-)INTEGER:INTEGERt' or '(+/-)INTEGER:INTEGERn'${normal}"; exit 1
	fi


	# Re-create the second chapters file array with new counter
	chaptcounter=0
	for ((i=0; i<=${#arraytxtsplit2[@]}-1; i++)); do
		if [[ ${arraytxtsplit2[((i+1))]} =~ $regextime ]] && [[ ${arraytxtsplit2[$i]} =~ $regexinteger ]]; then
			((chaptcounter++))
			arraytxtsplit2[$i]="$chaptcounter$cr"
		fi
	done


	# Remove an empty line at the end
	if [[ ${arraytxtsplit1[-1]} =~ $regexemptyline ]]; then
		unset arraytxtsplit1[-1]
	fi


	# Write to the txt file the contents of the two arrays.
	basename=${inputfilename%.*}
	firstfile="_1.txt"
	secondfile="_2.txt"
	printf "%s\n" "${arraytxtsplit1[@]}" > "$basename$firstfile"
	printf "%s\n" "${arraytxtsplit2[@]}" > "$basename$secondfile"


	# If -X (splittime) exists:
	unset arraytxt
	if [[ $splittime ]]; then
		# Find the first chapter time of the second file
		for ((i=0; i<=${#arraytxtsplit2[@]}; i++)); do
			line=${arraytxtsplit2[$i]}

			if [[ $line =~ $regextime ]]; then
				ha="${BASH_REMATCH[2]}"
				ma="${BASH_REMATCH[3]}"
				sa="${BASH_REMATCH[4]}"
				fa="${BASH_REMATCH[5]}"

				break
			fi
		done

	shifttime="-$ha:$ma:$sa,$fa"
	inputfilename="$basename$secondfile"
	shift_time
	unset shifttime
	fi
}


# Check for incompatible parameters
if [[ $inputfilename ]] && [[ $inputdirectory ]]; then
	echo "${red}Error: The parameters -i (Input file) and -d (Input directory) cannot be used together.${normal}"; exit 1
fi

if [[ $inputfilename ]] && [[ $synchronizedirectory ]]; then
	echo "${red}Error: The parameters -i (Input file) and -D (Synchronize with directory.) cannot be used together.${normal}"
	echo "Instead of \"Synchronize with directory\" you can use \"Synchronize with file\" (-y parameter)."; exit 1
fi


# Input file with wildcard support
master_function ()
{
	if [[ $shifttime ]]; then
		shift_time; (($? != 0)) && return 1
	fi

	if [[ $pal2ntsc ]] || [[ $ntsc2pal ]]; then
		change_fps; (($? != 0)) && return 1
	fi

	if [[ $adjustfirst ]]; then
		adjust_time; (($? != 0)) && return 1
	fi

	if [[ $adjustonlyfirst ]] || [[ $adjustonlylast ]]; then
		adjust_time_v2; (($? != 0)) && return 1
	fi

	if [[ $synchronizefile ]]; then
		synchronize_with_file; (($? != 0)) && return 1
	fi

	if [[ $findci ]] || [[ $findcs ]]; then
		find_text; (($? != 0)) && return 1
	fi

	if [[ $replace1 ]] || [[ $replace3 ]]; then
		replace_text; (($? != 0)) && return 1
	fi

	if [[ $jointxt ]]; then
		join_txt; (($? != 0)) && return 1
	fi

	if [[ $splittxt ]]; then
		split_txt; (($? != 0)) && return 1
	fi

	if ! [[ $txtok ]]; then
		basic_clean_up; (($? != 0)) && return 1
		txtok=""
	fi
}

if [[ $inputfilename ]]; then
	# Set globbing to case insensitive
	shopt -s nocaseglob

	old_IFS=$IFS		# save the field separator
	IFS=$'\n'			# new field separator, the end of line

	# Capture the output of ls to an array
	filesarray=( $(ls $inputfilename -p -d 2> /dev/null | grep -v /) )

	IFS=$old_IFS		# restore default field separator

	# Restore globbing to case sensitive
	shopt -u nocaseglob

	if ((${#filesarray[@]} == 0)); then
		echo "${red}Error: No file found.${normal}"; exit 1
	elif ((${#filesarray[@]} == 1)); then
		master_function

		# Exit if the return code of anything in the master_function is not 0
		if (($? != 0)); then
			exit 1
		else
			exit 0
		fi
	else
		numberoftxt=$(printf "%s\n" "${filesarray[@]}" | grep -i "\.txt$" -c)
		numberofogm=$(printf "%s\n" "${filesarray[@]}" | grep -i "\.ogm$" -c)
		numberofxml=$(printf "%s\n" "${filesarray[@]}" | grep -i "\.xml$" -c)
		echo "$numberoftxt .txt & $numberofogm .ogm & $numberofxml .xml found"
		((numberofother = ${#filesarray[@]} - $numberoftxt - $numberofogm - $numberofxml))
		if ((numberofother > 0)); then
			echo "$numberofother other file(s) were also found. These will be checked too and processed if they are chapters files."
		fi

		batchcounter=0
		numberofchaptersfiles=${#filesarray[@]}
		numberofchaptersfileslength=${#numberofchaptersfiles}
		for inputfilename in "${filesarray[@]}"; do
			((batchcounter++))
			batchcounterlength=${#batchcounter}
			spaceslength=$((numberofchaptersfileslength-batchcounterlength))
			case "$spaceslength" in
				0) precedingspaces="" ;;
				1) precedingspaces=" " ;;
				2) precedingspaces="  " ;;
				3) precedingspaces="   " ;;
				?) precedingspaces=$(eval printf "\ %.0s" {1..$spaceslength}) ;;
			esac
			printf "${bold}${green}[$precedingspaces$batchcounter/${#filesarray[@]}]${normal} "

			master_function
		done
		exit 0
	fi
fi


# Input directory with wildcard support
if [[ $inputdirectory ]]; then
	# Set globbing to case insensitive
	shopt -s nocaseglob

	old_IFS=$IFS		# save the field separator
	IFS=$'\n'			# new field separator, the end of line

	# Check if directory/ies exist
	if ! [[ $(ls -p -d $inputdirectory 2> /dev/null | grep /) ]]; then
		echo "${red}Error: No directory found.${normal}"; exit 1
	fi

	# Capture the output of ls to an array
	if [[ $synchronizefile ]] || [[ $jointxt ]]; then
		echo "${red}Error: Synchronize with file and Join txt cannot be used in batch mode.${normal}"
		echo "Instead of Synchronize with file you can use Synchronize with directory (-D parameter)."; exit 1
	else
		if [[ $recurse ]]; then
			filesarray=( $(find $inputdirectory -type f -iname "*.txt" -o -iname "*.ogm" -o -iname "*.xml" 2> /dev/null | sort) )
		else
			filesarray=( $(ls $inputdirectory/*.txt $inputdirectory/*.ogm $inputdirectory/*.xml 2> /dev/null) )
		fi
		echo "$(printf "%s\n" "${filesarray[@]}" | grep -i "\.txt$" -c) .txt & $(printf "%s\n" "${filesarray[@]}" | grep -i "\.ogm$" -c) .ogm & $(printf "%s\n" "${filesarray[@]}" | grep -i "\.xml$" -c) .xml file(s) found"
	fi

	IFS=$old_IFS		# restore default field separator

	# Restore globbing to case sensitive
	shopt -u nocaseglob

	batchcounter=0
	numberofchaptersfiles=${#filesarray[@]}
	numberofchaptersfileslength=${#numberofchaptersfiles}
	for inputfilename in "${filesarray[@]}"; do
		((batchcounter++))
		batchcounterlength=${#batchcounter}
		spaceslength=$((numberofchaptersfileslength-batchcounterlength))
		case "$spaceslength" in
			0) precedingspaces="" ;;
			1) precedingspaces=" " ;;
			2) precedingspaces="  " ;;
			3) precedingspaces="   " ;;
			?) precedingspaces=$(eval printf "\ %.0s" {1..$spaceslength}) ;;
		esac
		printf "${bold}${green}[$precedingspaces$batchcounter/${#filesarray[@]}]${normal} "

		if [[ $shifttime ]]; then
			shift_time
		fi

		if [[ $pal2ntsc ]] || [[ $ntsc2pal ]]; then
			change_fps
		fi

		if [[ $adjustfirst ]]; then
			adjust_time
		fi

		if [[ $adjustonlyfirst ]] || [[ $adjustonlylast ]]; then
			adjust_time_v2
		fi

		if [[ $synchronizedirectory ]]; then
			synchronize_with_file
		fi

		if [[ $findci ]] || [[ $findcs ]]; then
			find_text
		fi

		if [[ $replace1 ]] || [[ $replace3 ]]; then
			replace_text
		fi

		if [[ $splittxt ]]; then
			split_txt
		fi

		if ! [[ $txtok ]]; then
			basic_clean_up
			txtok=""
		fi
	done
	exit 0
fi
